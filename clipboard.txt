# reset to last commit
git reset --hard HEAD

# tag with date and time
TAG=$(date "+%Y-%m-%d--%H-%M") && git tag $TAG && git push origin $TAG

# to view profile data
gprof glos -pg

# to view a core dump
ulimit -c unlimited
# run the program to crash
# on ubuntu dump is at 
ll /var/lib/apport/coredump/
# use gdb
gdb glos /var/lib/apport/coredump/core._home_c_w_glos_glos.1000.a5eca36c-81b5-42ad-bcb0-6f602625ec20.3305893.268365950
# type 'bt' for stacktrace


cat stacktrace | awk '{print $2}'|cut -c 2-9 | while read addr; do
	addr2line -e glos $addr
done


#pragma once
#include <execinfo.h>
#include <stdio.h>
#include <stdlib.h>
#define stacktrace_depth 128
void stacktrace_print(FILE *f) {
  void *array[stacktrace_depth];
  const int size = backtrace(array, stacktrace_depth);
  char **strings = backtrace_symbols(array, size);
  for (int i = 0; i < size; i++) {
    fprintf(f, "%s\n", strings[i]);
  }
  free(strings);
}



#include <iostream>
#include <vector>
#include <future>

// Example task that doesn't return a result
void myTask(int id) {
    std::cout << "Task " << id << " started\n";
    // Perform some work
    for (int i = 0; i < 1000000; ++i) {
        // Do some computation
    }
    std::cout << "Task " << id << " completed\n";
}

int main() {
    std::vector<std::future<void>> futures;

    // Launch multiple tasks asynchronously
    for (int i = 0; i < 5; ++i) {
        futures.push_back(std::async(std::launch::async, myTask, i));
    }

    // Wait for all tasks to finish
    for (auto& future : futures) {
        future.wait();
    }

    std::cout << "All tasks completed\n";

    return 0;
}





#pragma once
// object
//   |
//   +--- actor
//   |      |
//   |      +--- ninja
//   |      |
//   |      +--- santa
//   |
//   +--- projectile
//   |       |
//   |       |
//   |       |

#define type_actor {'a',0,0,0,0,0,0,0}
#define type_ninja {'a','a',0,0,0,0,0,0}
#define type_santa {'a','b',0,0,0,0,0,0}
#define type_bullet {'b',0,0,0,0,0,0,0}
