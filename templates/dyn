#pragma once
#include<stdio.h>
//----------------------------------------------------------------------config

#define ${name}_initial_capacity 8
#define ${name}_bounds_check 1

//------------------------------------------------------------------------ def

typedef struct ${name}{
	${type} *data;
	unsigned count;
	unsigned cap;
}${name};
#define ${name}_def (${name}){0,0,0}

//--------------------------------------------------------------------- private

inline static void _${name}_insure_free_capcity(${name}*this,unsigned n){
	const unsigned rem=this->cap-this->count;
	if(rem>=n)
		return;
	if(this->data){
		unsigned new_cap=this->cap*2;
		${type} *new_data=realloc(this->data,sizeof(${type})*new_cap);
		if(!new_data){
			fprintf(stderr,"\nout-of-memory");
			fprintf(stderr,"\tfile: '%s'  line: %d\n\n",__FILE__,__LINE__);
			exit(-1);
		}
		if(new_data!=this->data){
			this->data=new_data;
		}
		this->cap=new_cap;
		return;
	}
	this->cap=${name}_initial_capacity;
	this->data=malloc(sizeof(${type})*this->cap);
	if(!this->data){
		fprintf(stderr,"\nout-of-memory");
		fprintf(stderr,"\tfile: '%s'  line: %d\n\n",__FILE__,__LINE__);
		exit(-1);
	}
}

//---------------------------------------------------------------------- public

inline static void ${name}_add(${name}*this,${type} o){
	_${name}_insure_free_capcity(this,1);
	*(this->data+this->count++)=o;
}

//-----------------------------------------------------------------------------

inline static ${type} ${name}_get(${name}*this,unsigned index){
#ifdef ${name}_bounds_check
	if(index>=this->count){
		fprintf(stderr,"\nindex-out-of-bounds");
		fprintf(stderr,"\t%s\n\n%d  index: %u    capacity: %u\n",
				__FILE__,__LINE__,index,this->cap);
		exit(-1);
	}
#endif
	${type} p=*(this->data+index);
	return p;
}

//-----------------------------------------------------------------------------

inline static ${type} ${name}_get_last(${name}*this){
	${type} p=*(this->data+this->count-1);
	return p;
}

//-----------------------------------------------------------------------------

inline static size_t ${name}_size_in_bytes(${name}*this){
	return this->count*sizeof(${type});
}

//-----------------------------------------------------------------------------

inline static void ${name}_free(${name}*this){
	if(!this->data)
		return;
	free(this->data);
}

//-----------------------------------------------------------------------------

inline static void ${name}_add_list(${name}*this,/*copies*/const ${type}*str,size_t n){
	//? optimize memcpy
	const ${type}*p=str;
	while(n--){
		_${name}_insure_free_capcity(this,1);
		*(this->data+this->count++)=*p++;
	}
}

//-----------------------------------------------------------------------------

inline static void ${name}_add_string(${name}*this,/*copies*/const ${type}*str){
	//? optimize
	const ${type}*p=str;
	while(*p){
		_${name}_insure_free_capcity(this,1);
		*(this->data+this->count++)=*p++;
	}
}

//-----------------------------------------------------------------------------

inline static void ${name}_write_to_fd(${name}*this,int fd){
	if(!this->data)
		return;
	write(fd,this->data,this->count);
}

//-----------------------------------------------------------------------------

inline static ${name} ${name}_from_file(const char*path){
	FILE*f=fopen(path,"rb");
	if(!f){
		perror("\ncannot open");
		fprintf(stderr,"\t%s\n\n%s %d\n",path,__FILE__,__LINE__);
		exit(-1);
	}
	long sk=fseek(f,0,SEEK_END);
	if(sk<0){
		fprintf(stderr,"\nwhile fseek\n");
		fprintf(stderr,"\t\n%s %d\n",__FILE__,__LINE__);
		exit(-1);
	}
	long length=ftell(f);
	if(length<0){
		fprintf(stderr,"\nwhile ftell\n");
		fprintf(stderr,"\t\n%s %d\n",__FILE__,__LINE__);
		exit(-1);
	}
	rewind(f);
	${type}*filedata=(${type}*)malloc((size_t)length+1);
	if(!filedata){
		fprintf(stderr,"\nout-of-memory\n");
		fprintf(stderr,"\t\n%s %d\n",__FILE__,__LINE__);
		exit(-1);
	}
	size_t n=fread(filedata,1,(size_t)length+1,f);
	if(n!=(size_t)length){
		fprintf(stderr,"\nnot-a-full-read\n");
		fprintf(stderr,"\t\n%s %d\n",__FILE__,__LINE__);
		exit(-1);
	}
	fclose(f);
	filedata[length]=0;

	return (${name}){
		.data=filedata,
		.count=((unsigned)length+1)/sizeof(${type}),
		.cap=(unsigned)length+1
	};
}

//-----------------------------------------------------------------------------
