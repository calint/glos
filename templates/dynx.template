template<dynf>
//------------------------------------------------------------------ ${template}
#pragma once
#include<stdlib.h>

#define ${template}_initial_cap 8
#define ${template}_realloc_strategy 'a'
#define ${template}_bounds_check 1

typedef struct ${template}{
	float*data;/*owns*/
	size_t size;
	size_t cap;
}${template};
${template} _${template}_init_={NULL,0,0};

//--------------------------------------------------------------------- private

inline static void __${template}_insure_free_capcity(${template}*this,size_t n){
	const size_t rem=this->cap-this->size;
	if(rem>=n)
		return;
	if(this->data){
		size_t new_cap;
		switch(${template}_realloc_strategy){
		case 'a':
			new_cap=this->cap*2;
			break;
		default:
			fprintf(stderr,"\nunknown-strategy");
			fprintf(stderr,"\tfile: '%s'  line: %d\n\n",__FILE__,__LINE__);
			exit(-1);
		}

		printf("   re-allocating vector %p\n",this->data);
		void* *new_data=realloc(this->data,sizeof(float)*new_cap);
		if(!new_data){
			fprintf(stderr,"\nout-of-memory");
			fprintf(stderr,"\tfile: '%s'  line: %d\n\n",__FILE__,__LINE__);
			exit(-1);
		}
		if(new_data!=this->data){ // re-locate
			printf("   re-allocated vector %p to %p\n",this->data,new_data);
			this->data=new_data;
		}
		this->cap=new_cap;
		return;
	}
	// initialize data
	this->cap=${template}_initial_cap;
	this->data=malloc(sizeof(float)*this->cap);
	if(!this->data){
		fprintf(stderr,"\nout-of-memory");
		fprintf(stderr,"\tfile: '%s'  line: %d\n\n",__FILE__,__LINE__);
		exit(-1);
	}
}


//---------------------------------------------------------------------- public

inline static void ${template}_add(${template}*this,float f){
	__${template}_insure_free_capcity(this,1);
	*(this->data+this->size++)=f;
}

//-----------------------------------------------------------------------------

inline static float ${template}_get(${template}*this,size_t index){
#ifdef ${template}_bounds_check
	if(index>=this->cap){
		fprintf(stderr,"\nindex-out-of-bounds");
		fprintf(stderr,"\t%s\n\n%d  index: %zu    capacity: %zu\n",
				__FILE__,__LINE__,index,this->cap);
		exit(-1);
	}
#endif
	return*(this->data+index);
}

//-----------------------------------------------------------------------------

inline static size_t ${template}_size_in_bytes(${template}*this){
	return this->size*sizeof(float);
}

//-----------------------------------------------------------------------------

inline static void ${template}_free(${template}*this){
	if(!this->data)
		return;
	free(this->data);
}

//-----------------------------------------------------------------------------
