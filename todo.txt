[ ] net_server: read/write instead of recv(...,0) and send(...,0)
[ ] net: when server disconnects there is no print out
    => use fflush(stdout); before terminating
[ ] object: update Mmw if it will be rendered
[x] engine: review mutexes and why initial waiting for render can hang without the 'if'
    => bug in predicate
[x] engine: frame_context.ms in network mode should be from server
[x] frame_context: 64 bit ms time
[ ] consider inverting meaning of bool return value from 'update'
[ ] object render culling using camera frustum, position and bounding sphere
[ ] grid cell render culling
[x] implement sample game
[x] use a build system instead of make.sh
    => and also make.sh
[ ] planes::update_model_to_world could save frame_num from context to shorten
    the decision if cached values are valids
[ ] ? racing condition on net.states between where render thread and update thread
[o] halt development and tidy up
[x]   'unsigned' instead of 'int' where size cannot be negative
      => in 64 bit architecture 'int' instead of 'unsigned' should be considered
[x]   use size_t for sizes and indexes (assumes 64 bit architecture)
[x]   review application code
[x]   print out source location when std::abort()
[ ]   use c++ random number generator
[x]   class private members at the bottom of the declaration
[x]   use uint32_t instead of unsigned int32_t etc
      => class members fixed. in code less relevant
[ ]   consider a more standard source layout without depending on include order
[x]   use gl_element_array_buffer (where appropriate)
[ ]   use glDebugMessageCallback
[ ]   clang-tidy
[ ]   cmake or premake and automatically download dependencies using git submodules
[x]   use glm::sin, cos etc
[x]   consider verbose self documenting code
[x]   move object::volume into physics
      => moved into object
[x]   review and delete obsolete notes
[ ]   net_server as separate application
[x]   ref& const, bool const, etc
[x]     arguments
[x]     code
[x]   ++i instead of i++
[ ]   friend cell to object?
[x]   const correctness
[x]   const everything
[ ]   constexpr everything
[ ]   struct vertex used for sizeof only
[ ] grid: static vs moving vs bullets vs scenery objects
[ ] glo::load: better printout
[ ] glo: optimize ranges by merging non-texture draws
[ ] use string_view instead of const char*
[ ] note about the absolute texture path in mtl files
[x] rename 'node' to something better
    => moved into object
[x] use object Mmw when updating volume::planes
[x] glo: after upload to gpu buffers can be deleted
[x] glo: load obj and planes in a consistent way
[ ] object size and content is not cache friendly. consider components
[ ] volume::planes - ability to store some extra points without normals for use
    in collision detection
[ ] use "moving towards each other" vector to cull collision detection
[ ] multiple collision detection convex volumes per object
[ ] collision detection: collision_context such as collision normal, plane etc
[ ] collision reaction: tiny random added to 'dt' for each object to avoid
    mathematical precision example: "o>  o  <o"   "ooo" instead of  "o<  o  >o"
[ ] object: checked_collisions make minimum size of vector to e.g. 8
[x] glo: upgrade to glGenVertexArrays (opengl es3)
[?] move init() and free() into constructor and destructor
    => it might be better to know exactly when init and free is done
[x] shaders: move program activation from 'main' to 'program'
[x] glos.get_by_index instead of name in constructors of game objects
[x] node.glo maybe should be an index instead of a pointer in case glos
    are loaded during game play and vector reallocates
[x] move 'collision_bits' and 'collision_mask' to 'object' and solve circular
    reference by implementation moving the implementation outside the 'grid_ifc'
    => no circular references
    => 'grid_ifc' removed and implementation added to 'object'
[x] render on separate thread
    => update loop on other thread, render loop in main thread
[-] grid_ifc: hash_set instead of vector for checked_collisions
    => degrades performance from 27 fps to 18 fps in test case
[-] o1store: new objects list that is applied after update
    causing allocated list to be stable during update and collision_resolution
    => 'objects' made 'o1store' private and handles list end limit
[ ] camera: update matrix only if necessary
[x] c++ conversion
[x]   replace dynp, dyni, dynf with vector
[x]   replace str with string
[x] namespaces
[x] hpp files included by main.cpp
[x] convert structs to classes
[x] use glm library for math
[x] multithreaded grid update
    => initial try with futures and async lambda degrades performance by 50%
    => try with ~25K objects
    std::for_each(std::execution::par_unseq,...) gives 7 fps instead of 5 fps
    => with less objects (<1K) par_unseq degrades performance by 50%
    => incrementing metrics attributes have a big impact on performance when multithreading
       turning those metrics off doubles the performance. why so expensive?
       with metrics turned of in cell::resolve_collisions multithreaded
       performance gain is 3x compared to single threaded (with no rendering)
[x] deleted objects list created during 'update'
[ ] shader: mtx_wvp * mtx_mw   is it better with mtx_mwvp?
[x] use unique_ptr instead of new and delete
    => o1store for objects
[ ] consider: https://github.com/alugowski/task-thread-pool for simple multithreading
------------------------------
[x] dynamic pointer vector
[x] texturing
[x] obj format
[x]   colors
[x]   texture coords
[x]   materials
[ ]     global
[x]   textures
[x]   render
[x]   scene
[x]     to objects
[ ]     center/scale/position
[x]   faces to ccw
[ ] draw bounding volume
[x]   sphere
[ ]   box
[ ]   planes
[x] multiple materials in render
[o] collision detection 
[o]   bounding volume
[x]     sphere
[x]       vs sphere
[x]       vs plane
[-]       vs box
[o]     planes
[-]       vs box
[x]       vs planes
[-]     box
[-]       vs box
[-]     line
[-]       vs sphere
[-]       planes 
[-]     empty/solids
[-]       boolean ops
[o] collision physics/animatics
[x]   sphere vs sphere
[ ]   box vs box
[ ]   sphere vs plane
[ ]   sphere vs box
[x] grid
[x]   render
[ ]     cull
[x]   update
[x]   multicore
[x] keyshub
[x]   client
[x]   server
[x]   multiplayer
[x] camera
[x]   projection
[x]     orthonormal
[x]     perspective
[x]   look-at
[ ]   click select
[x]   follow
[ ]     pd regulator
[ ]     pid regulator
[ ]   script
[ ]     path
[ ]     focus
[ ] hud
[ ]   console
[ ] draw text
[x] mouse
[x]   fps controls
[ ]   alternative controls
[x] light sources
[x]   ambient
[ ] shadow map
[ ]   render to texture
[x]   use several programs
[ ]   ortho
[ ]     zoom zbuf render to encompass view frustum
[ ]   persp
[ ] hierarchial objects
[ ]   cached matrices
[ ]     model-to-local
[ ]     local-to-world
[ ]   collisions
[ ]     root object bounding volume, recursive
[ ]     objects individually of hierarchy
[x] draw grid
[x]   sky dome
[x]   ground plane
[x] 3D newton conservation with spheres
[x]   1D cradle
[x]   2D
[x]   3D
