[ ] look at std::aligned_alloc to align o1store
[x] cell: break up 'resolve_collisions' for better cache coherence
[x] reorganize order and align members as expected to be accessed in the subsystems aware of the
    cache lines (64B)
[ ] release and continue with sandbox game in 'glosi'
[ ]   render cull cells
[ ]   render cull objects
[x]   fix multithreading issues
[ ]     in multiplayer
[ ]   grid: static vs moving vs bullets vs scenery objects
[ ]   glob::load: optimize ranges by merging non-textured materials since all
      material info is saved in the vertices
[ ] object: consider making all members private
[ ] cell::resolve_collisions: consider/try making a vector of objects to check collisions
    with if bounding spheres in collision considering cache coherence
[x] o1store: nice exit when objects exceeded capacity
[x] examine plane representation Ax + By + Cz + D = 0 where w is D
    then get distance: dot(plane, point);
[x] collision detection: large sphere vs "pointy" convex volume gives false positives
    when the sphere is in front of the "pointy" part because the planes outside the object
    give false positive with distance to plane being closer to sphere than radius
    => more planes can be added to the "pointy" object
    => sat method (separating axis theorem) using normals for projection axis
       has edge cases and does give false positives
[ ] convert token.h
[ ] use c++ random number generator
[ ] rand() is not thread-safe
[ ] cell.update does what object::update does since it always returns true
[ ] bounding box. OBB 3 normals, width, height
    check if point is inside: 3 dot products + additions and comparisons
[ ] use string_view instead of const char*
[ ] object: changing glob_ix should invalidate planes
    => for now planes.invalidated flag
[ ] object::get_updated_Mmw_matrix: also compare with frame_context.frame_num in
    a non synchronized statement
[ ] objects.free(): what if destructors created new objects
[ ] net_server: read/write instead of recv(...,0) and send(...,0)
[ ] net_server: record client signals and then replay the session
[ ] object: update Mmw if it will be rendered
[ ] object render culling using camera frustum, position and bounding sphere
[ ] grid cell render culling
[ ] planes::update_model_to_world could save frame_num from context to shorten
    the decision if cached values are valid
[ ] use glDebugMessageCallback
[ ] cmake or premake and automatically download dependencies using git submodules
[ ] net_server as separate application
[ ] constexpr everything
[ ] struct vertex used for sizeof only
[ ] fix itm anti-pattern
[ ] note about the absolute texture path in mtl files
[ ] object size and content is not cache friendly. consider components
[ ] use "moving towards each other" vector to cull collision detection
[ ] multiple collision detection convex volumes per object
[ ] collision detection: collision_context such as collision normal, plane etc
[ ] collision reaction: tiny random added to 'dt' for each object to avoid
    mathematical precision example: "o>  o  <o"   "ooo" instead of  "o<  o  >o"
[ ] object: checked_collisions make minimum size of vector to e.g. 8
[ ] camera: update matrix only if necessary
[ ] shader: mtx_wvp * mtx_mw   is it better with mtx_mwvp?
[ ] consider: https://github.com/alugowski/task-thread-pool for simple multithreading
------------------------------
[x] review engine source
[x]   cell
[x]   object
[x]   planes
[x]   camera
[x]   engine
[x]   glob
[x]   grid
[x]   hud
[x]   material
[x]   metrics
[x]   net_server
[x]   net
[x]   o1store
[x]   sdl
[x]   shaders
[x]   texture
[x]   token
[x]   windows
[x] sanitize
[x]   thread
[x]   memory
[x] object: updated_at_tick and rendered_at_tick is uint64_t. uint32_t enough for purpose?
[x] profile
[x] sanitize
[x] glob::load: better printout
[x] ? racing condition on net.states between where render thread and update thread
    => it is ok. current signals are copied to net.states and the object
       references those signals
[x] volume::planes - ability to store some extra points without normals for use
    in collision detection
[x] accessing global frame_context from threads is 1.8% of profiling 
    time without rendering on a threaded grid
    => misread
[x] halt development and tidy up
[x]   'unsigned' instead of 'int' where size cannot be negative
      => in 64 bit architecture 'int' instead of 'unsigned' should be considered
[x]   use size_t for sizes and indexes (assumes 64 bit architecture)
[x]   review application code
[x]   print out source location when std::abort()
[x]   class private members at the bottom of the declaration
[x]   use uint32_t instead of unsigned int32_t etc
      => class members fixed. in code less relevant
[-]   consider a more standard source layout without depending on include order
      => source in hpp and the concept of the program being one file is kept
[x]   use gl_element_array_buffer (where appropriate)
[x]   use glm::sin, cos etc
[x]   consider verbose self documenting code
[x]   move object::volume into physics
      => moved into object
[x]   review and delete obsolete notes
[x]   ref& const, bool const, etc
[x]     arguments
[x]     code
[x]   ++i instead of i++
[x]   friend cell to object?
      => and grid
[x]   const correctness
[x]   const everything
[x] clang-tidy
[x] try using cell_entry{pos,radius,collbits,collmsk} instead of object pointer for 
    better cache utilization in hot path
    => first impl 10% improvement in 'upd_ms' for the 64K objects grid
[x] metrics gives a large first fps when vsync is on
    => seems like SDL2 issue
[x] consider inverting meaning of bool return value from 'update' and 'on_collision'
[x] use unique_ptr instead of new and delete
    => o1store for objects
[x] net: when server disconnects there is no print out
    => use fflush(stdout); before terminating
    => fflush(stderr)
[x] engine: review mutexes and why initial waiting for render can hang without the 'if'
    => bug in predicate
[x] engine: frame_context.ms in network mode should be from server
[x] frame_context: 64 bit ms time
[x] implement sample game
[x] use a build system instead of make.sh
    => and also make.sh
[x] rename 'node' to something better
    => moved into object
[x] use object Mmw when updating volume::planes
[x] glo: after upload to gpu buffers can be deleted
[x] glo: load obj and planes in a consistent way
[x] glo: upgrade to glGenVertexArrays (opengl es3)
[?] move init() and free() into constructor and destructor
    => it might be better to know exactly when init and free is done
[x] shaders: move program activation from 'main' to 'program'
[x] glos.get_by_index instead of name in constructors of game objects
[x] node.glo maybe should be an index instead of a pointer in case glos
    are loaded during game play and vector reallocates
[x] move 'collision_bits' and 'collision_mask' to 'object' and solve circular
    reference by implementation moving the implementation outside the 'grid_ifc'
    => no circular references
    => 'grid_ifc' removed and implementation added to 'object'
[x] render on separate thread
    => update loop on other thread, render loop in main thread
[-] grid_ifc: hash_set instead of vector for checked_collisions
    => degrades performance from 27 fps to 18 fps in test case
[-] o1store: new objects list that is applied after update
    causing allocated list to be stable during update and collision_resolution
    => 'objects' made 'o1store' private and handles list end limit
[x] c++ conversion
[x]   replace dynp, dyni, dynf with vector
[x]   replace str with string
[x] namespaces
[x] hpp files included by main.cpp
[x] convert structs to classes
[x] use glm library for math
[x] multithreaded grid update
    => initial try with futures and async lambda degrades performance by 50%
    => try with ~25K objects
    std::for_each(std::execution::par_unseq,...) gives 7 fps instead of 5 fps
    => with less objects (<1K) par_unseq degrades performance by 50%
    => incrementing metrics attributes have a big impact on performance when multithreading
       turning those metrics off doubles the performance. why so expensive?
       with metrics turned of in cell::resolve_collisions multithreaded
       performance gain is 3x compared to single threaded (with no rendering)
[x] deleted objects list created during 'update'
------------------------------------------------------------------
[x] dynamic pointer vector
[x] texturing
[x] obj format
[x]   colors
[x]   texture coords
[x]   materials
[ ]     global
[x]   textures
[x]   render
[x]   scene
[x]     to objects
[ ]     center/scale/position
[x]   faces to ccw
[x] draw bounding volume
[x]   sphere
[-]   box
[x]   planes
[x] multiple materials in render
[x] collision detection 
[x]   bounding volume
[x]     sphere
[x]       vs sphere
[x]       vs plane
[-]       vs box
[x]     planes
[-]       vs box
[x]       vs planes
[-]     box
[-]       vs box
[-]     line
[-]       vs sphere
[-]       planes 
[-]     empty/solids
[-]       boolean ops
[o] collision physics/animatics
[x]   sphere vs sphere
[-]   box vs box
[ ]   sphere vs plane
[-]   sphere vs box
[ ]   planes vs planes
[x] grid
[x]   render
[ ]     cull
[x]   update
[x]   multicore
[x] keyshub
[x]   client
[x]   server
[x]   multiplayer
[x] camera
[x]   projection
[x]     orthonormal
[x]     perspective
[x]   look-at
[ ]   click select
[x]   follow
[ ]     pd regulator
[ ]     pid regulator
[ ]   script
[ ]     path
[ ]     focus
[x] hud
[x]   console
[x] draw text
[x] mouse
[x]   fps controls
[ ]   alternative controls
[x] light sources
[x]   ambient
[ ] shadow map
[ ]   render to texture
[x]   use several programs
[ ]   ortho
[ ]     zoom zbuf render to encompass view frustum
[ ]   persp
[ ] hierarchial objects
[ ]   cached matrices
[ ]     model-to-local
[ ]     local-to-world
[ ]   collisions
[ ]     root object bounding volume, recursive
[ ]     objects individually of hierarchy
[x] draw grid
[x]   sky dome
[x]   ground plane
[x] 3D newton conservation with spheres
[x]   1D cradle
[x]   2D
[x]   3D
